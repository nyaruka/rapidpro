# Generated by Django 5.2.2 on 2025-08-19 19:04

from datetime import datetime, timezone as tzone

from django.db import migrations
from django.db.models import Prefetch

from temba.utils import dynamo
from temba.utils.uuid import uuid7

# don't backfill any events newer than this since they've already been created
# TODO remove this when we're done backfilling
events_before = datetime(2025, 8, 19, 18, 0, 0, 0, tzone.utc)

status_map = {
    "A": "active",
    "W": "waiting",
    "C": "completed",
    "I": "interrupted",
    "X": "expired",
    "F": "failed",
}


def backfill_run_events(apps, schema_editor):
    FlowRun = apps.get_model("flows", "FlowRun")
    Flow = apps.get_model("flows", "Flow")
    Contact = apps.get_model("contacts", "Contact")

    runs = FlowRun.objects.filter(org__is_active=True, contact__is_active=True, flow__is_system=False).prefetch_related(
        Prefetch("contact", Contact.objects.only("uuid")),
        Prefetch("flow", Flow.objects.only("uuid", "name")),
    )

    before_id = None
    num_written = 0

    while True:
        batch = runs.order_by("-id")
        if before_id:
            batch = batch.filter(id__lt=before_id)

        batch = list(batch[:100])
        if not batch:
            break

        try:
            with dynamo.HISTORY.batch_writer() as writer:
                for run in batch:
                    flow_ref = {"uuid": str(run.flow.uuid), "name": run.flow.name}

                    if run.created_on < events_before:
                        writer.put_item(
                            {
                                "PK": f"con#{run.contact.uuid}",
                                "SK": f"evt#{uuid7(run.created_on)}",
                                "OrgID": run.org_id,
                                "Data": {
                                    "type": "run_started",
                                    "created_on": run.created_on.isoformat(),
                                    "run_uuid": str(run.uuid),
                                    "flow": flow_ref,
                                },
                            }
                        )
                    if run.exited_on and run.exited_on < events_before:
                        writer.put_item(
                            {
                                "PK": f"con#{run.contact.uuid}",
                                "SK": f"evt#{uuid7(run.exited_on)}",
                                "OrgID": run.org_id,
                                "Data": {
                                    "type": "run_ended",
                                    "created_on": run.exited_on.isoformat(),
                                    "run_uuid": str(run.uuid),
                                    "flow": flow_ref,
                                    "status": status_map[run.status],
                                },
                            }
                        )

                    num_written += 1
                    before_id = run.id
        except Exception as e:  # pragma: no cover
            print(e)
            print(f"before_id={before_id}")
            break

        last_id, last_created_on = batch[-1].id, batch[-1].created_on

        print(f"Wrote {num_written} run events (last id={last_id}, created_on={last_created_on.isoformat()})")


def apply_manual():  # pragma: no cover
    from django.apps import apps

    backfill_run_events(apps, None)


class Migration(migrations.Migration):

    dependencies = [
        ("flows", "0394_remove_flowsession_call_remove_flowsession_contact_and_more"),
    ]

    operations = [
        migrations.RunPython(backfill_run_events, reverse_code=migrations.RunPython.noop),
    ]
